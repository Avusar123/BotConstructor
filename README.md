## Цель проекта

Сегодня огромное количество компаний используют интегрированных в социальные сети чат-ботов. По моему опыту такие приложения очень часто схожи по функциональности, а порой и вовсе идентичны, но все равно даже на такие проекты как правило уходит немало времени и денег организации, в том числе оплата услуг программистов и аренда оборудования для этих ботов. Основная цель проекта - сведение процесса разработки и развертывания рутинных и напротив сложных ботов для различных социальных сетей до уровня удобного NoCode решения, которое можно использовать для программирования практически любой логики: от простых вопрос-ответов до обработки заказов через платежную систему и запросов к кастомным API для получения нужного ответа (В РАЗРАБОТКЕ).

В результате пользователь получает функциональный веб-интерфейс, который позволяет задать нужную конфигурацию боту, полностью написать логику самому через конструктор или взять уже готовые части из шаблонов, опубликованных другими пользователями м задеплоить бота нажатием всего одной кнопки, без необходимости докупать дополнительные сервера и настраивать их. 

## Стек технологий

- Java SE, Jakarta, Hibernate
- JPA, PostgreSQL, Redis
- Maven, Spring Boot, Spring DI
- Spring Security, Spring MVC, Spring Web, Docker

## Описание моделей БД

- Middleware (промежуточный слой) - наименьшая единица конструирования бота, которая является абстрактной дата моделью для соответствующего ему обработчика события, в проекте имеет две абстрактные ветки: 
	- Trigger - промежуточный слой останавливающий обработку запроса при отсутствии какого-либо условия
	- Action - конкретное действие, может быть как техническим (вроде создания переменной в окружении), так и конкретным (к примеру, отправка сообщения клиенту)
- Event - абстрактное событие, которое может поступить как от бота, так и от внешнего API
- ProviderConfiguration - абстрактная конфигурация **провайдера**, которая используется для задания настроек бота
- ProcessingBlock - блок, принимающий только события определенного типа, является контейнером для Middleware
- BotModel - модель, описывающая бота с точки зрения базы данных, содержит список ProcessingBlock, а также ProviderConfiguration

## Принцип работы приложения

#### Как работает конструктор?

Взаимодействие с пользователем происходит через MVC модель. Вначале создается пустая модель BotModel, у которой заполнено лишь имя бота, потом пользователь выбирает тип конфигурации и заполняет ее поля (например, для телеграмм это Token бота), потом пользователь попадает в список ProcessingBlock, добавляя новые он тем самым задает поведение программы при определенных событиях, если несколько блоков ссылаются на одно событие, то они выполнятся последовательно, в каждом блоке пользователь создает сколько угодно произвольных Middleware, но первыми обычно идут триггеры на определенное условие (к примеру, проверка, что пользователь использовал определенную команду). 

Промежуточные слои поддерживают форматирование, к примеру строка

```
"Hello, {message:chatId}" -> "Hello, 1231231"
```

Здесь,  **message**:chatId - переменная окружения, полученная после сериализации события объектом EventSerializer в Map<String, String>. 

Форматирование также поддерживает использование массивов, к примеру можно добавить слой, реагирующий на использование команды следующим образом:

Изначальное сообщение пользователя: ``/send 123123123 "Привет!"`` в итоге создаст

```
sendData:size -> 2
sendData:1 -> 123123123
sendData:2 -> Привет!
```

Здесь,  **sendData** - пользовательская переменная, указанная при создании слоя.

После создания всех блоков со слоями пользователь нажимает кнопку запустить и происходит запуск процесса обработки

#### Как работает процесс обработки бота

![BotConstructorNew drawio](https://github.com/user-attachments/assets/b0813be2-7316-4287-b62e-505fa0b9714f)

Выше нарисованы все ОСНОВНЫЕ классы, участвующие в обработке сообщений от пользователей, а также их взаимосвязи друг с другом. 

В момент нажатия на кнопку запустить этот запрос получает RunningEntrypoint класс, который в данный момент имеет локальную In-Memory реализацию, задача данного класса это по конфигурации бота получить нужный Provider (к примеру, Telegram), вызвать у него метод Initialize для добавления нужных данных и вызвать StartListner, чтобы начать выполнение. Далее класс сохраняет работающий провайдер и возможно отвечает на связанные с ним запросы (к примеру, запрос на отключение провайдера). Далее при возникновении какого-то сообщения от пользователя формируется Event, который потом передается в EventProcessor, где и происходит его дальнейшая обработка.

Проект ориентирован на максимальную гибкость, как со стороны пользователя, так и со стороны разработчика, чтобы всегда иметь возможность вписаться в текущие требования.
